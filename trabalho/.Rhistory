install.packages("rmarkdown")
install.packages("shiny")
install.packages("tidyverse", dempendecies = TRUE)
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("curl")
install.packages("curl")
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("openssl")
install.packages("openssl")
install.packages("tidyverse")
install.packages("devtools")
install.packages("magrittr")
install.packages("dplyr")
setwd("~/2018-2/inferencia/trabalho")
# Trabalho inferência
citation(R)
# Trabalho inferência
citation("R")
# Trabalho inferência
citation()
# Exponencial
x <- seq(0, 2, l = 100)
b0 = log(1)
b1 = -2
eta = b0 +b1*x # preditor de cada lambda
plot(eta ~ x)
lambda = exp(eta)
eta
lambda
summary(lambda)
plot(lambda ~ x)
# Simulação das observações
set.seed(123)
y = rexp(100, rate = lambda)
plot(y ~ x)
summary(y)
# criando as observações censuradas
y1 <- y - 0.03
y2 <- y + 0.03
censu <- data.frame(y1, y2)
censu
#verossimilhança da censura
# função de verossimilhança
V_censu <- c()
for(i in 1:100){
V_censu[i] <- pexp(censu$y2[i], rate = lambda[i]) - pexp(censu$y1[i], rate = lambda[i])
}
plot(V_censu)
#log-verossimilhança
ll_censu <- log(V_censu)
ll_censu
plot(censu)
plot(censu$y1)
plot(censu$y2)
plot(censu$y2)
#log-verossimilhança
ll_censu <- log(V_censu)
ll_censu
plot(-ll_censu)
# Verossimilhança
vero <- sum(-ll_censu)
vero
summary(lambda)
lambda = exp(b0 +b1*x)
summary(lambda)
# Simulação das observações
set.seed(123)
y = rexp(100, rate = lambda)
plot(y ~ x)
summary(y)
plot(censu$y1 ~ censu$y2)
plot(censu$y1 ~ x)
plot(censu$y2 ~ x)
plot(censu$y1 ~ x)
plot(censu$y2 ~ x)
plot(censu$y1 ~ x)
2
plot(censu$y2)
plot(y ~ x, cex=2)
plot(y ~ x, cex=2)
plot(y ~ x)
curve(ll_censu)
ll_censu
curve(ll_censu)
summary(ll_censu)
curve(ll_censu, -11.680, -2.966)
curve(log(V_censu), -11.680, -2.966)
censu
# avaliar
bla <- ll(theta = c(log(1), -2), inferior = censu$y1, superior = censu$y2, x = x)
#estimando
#log-verossimilhança
ll <- function(theta, inferior, superior, x){
lambda = exp(theta[1] + theta[2]*x)
output <- -sum(log(pexp(superior, rate = lambda) - pexp(inferior, rate = lambda)))
return(output)
}
# avaliar
bla <- ll(theta = c(log(1), -2), inferior = censu$y1, superior = censu$y2, x = x)
#Estimando
#log-verossimilhança
ll <- function(theta, inferior, superior, x){
lambda = exp(theta[1] + theta[2]*x)
output <- -sum(log(pexp(superior, rate = lambda) - pexp(inferior, rate = lambda)))
return(output)
}
# Avaliando
ll(theta = c(log(1), -2), inferior = censura$yu, superior = censura$yv, x = x)
ll(theta = c(log(0.5), -0.5), inferior = censu$y1, superior = censu$y2, x = x)
#otimizando numericamente
#colocar ll para retornar o negativo da ll antes
oo <- optim(par = c(1, -3), fn = ll, inferior = censu$y1,
superior = censu$y2, x = x, hessian = TRUE)
#hessian são os valores das funções score
str(oo)
oo$par
oo$value
oo$convergence
oo$message
oo$hessian
